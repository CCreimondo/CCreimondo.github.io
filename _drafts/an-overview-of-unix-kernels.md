# An Overview of Unix Kernels


## The User/Kernel Model
- 区分User/Kernel状态是Unix内核的一种机制。具体实现中，内核封装大量的代码并留出syscalls以供程序调用。
- 用户态指CPU此时执行的代码是非kernel代码，内核态指CPU此时执行的代码是内核代码，且此时代码运行所需的栈是内核栈（分配自内核内存）。用户进程通过system call从用户态转换到内核态。内核态的进程有一个很形象的名字－－内核例程（kernel routine）。
- 例程是处于内核态的进程。我们知道，内核代码只是静静的躺在内存中，它并不会自己执行，所以它需要以下机制被动的执行：
  - System Call
  - Exception & Interrupt
  - Kernel Thread
- 除了用户进程，还有几个从开机到关机一直运行的内核线程（kernel thread），然后再也没有其它形式的进程了。


## Reentrant Kernels & Kernel Control Path
首先，明确这样一个计算机模型－－计算资源是共享的（CPU），存储资源（Memory）每个进程都可以私有。所以内核需要一种机制来保证各个进程合理有序的使用计算资源。

可重入的内核意味内核例程可以随时切换。考虑一个不可重入内核，那么当例程执行时，会阻塞（占有）一切，直到自己执行完（返回用户态）。（没栗子我也想不清楚可重入内核的意思，再说。。。

内核控制路径（kernel control path）表示内核处理器系统调用、异常或中断所执行的指令序列。每个哪个控制路径都引用它自己的私有内核栈。一个内核例程对应一条内核控制路径。

如何才能让内核例程随时可切换（即如何在内核中安全的切换内核控制路径）？一个可切换的例程至少有一个地方（可被内核管理）可以让它保存当前它独有的寄存器信息（CPU是共享的，保存它的信息很重要）。我们知道进程操作系统可调度的最小单位，设计上每一个进程都有自己的`task_struct`用于记录它所拥有的一切（寄存器值、PID、内存等等）。所以，代表一个进程运行是一个不错的选择。被当前进程召唤（system call）的例程自然可以用当前进程的`task_struct`保存它独有的寄存器信息（该例程就是当前进程的内核态，天然可调度）。Exception中，例程代表当前进程，天然可调度。Kernel thread（Linux中，thread是特殊的进程）天然可调度。但是，interrupt（硬件产生）召唤的中断处理程序借谁的身份来运行呢？《深入理解LINUX内核》上说，中断可嵌套（即中断处理例程可被其它中断打断），此时的两个中断在同一个进程（第一个中断前的那个被挂起的进程，还是第一个中断借来的内核线程？）的可执行上下文中，所花费的系统CPU时间都算给这个进程，然而，中断处理程序无需代表这个进程运行。问题是，如果没有一个进程身份，中断处理例程被打断时，该把寄存器信息存到哪里去？


## Process Address Space
一个进程私有的地址空间有私有栈、数据区和代码区。当在内核态运行时，进程访问内核的数据区和代码区。


## Synchronization and Critical Regions
可重入内核中需要有同步机制：如果内核控制路径对某个内核数据结构进行操作时被挂起，那么，其它的内核控制路径就不应该再对该数据结构进行操作。

- 对全局变量的安全访问可通过原子操作（atomic operation）来保证。e.g. 1+1=2 -> （load、operate、save）
- 无法用单一操作访问的数据结构通过临界区（critical region）来保证。


## Q&A
Q1.在以下程序中，哪些部分在user space执行，哪部分在kernel space执行？

```c
int fact(n) {
    return ((n == 2) ? 2 : n * f(n - 1))
}

int main() {
    int rv = fact(10);
    
    return 0;
}
```
