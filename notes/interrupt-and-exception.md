# Interrupt and Exception

## softirq
### do_softirq()
以下情况会周期性检查本地挂起的软中断并执行do_softirq()：
- local_bh_enable()时
- irq_exit()时
- smp_apic_timer_interrupt()后
- 完成处理器间中所触发的函数
- ksoftirqd/n被唤醒

### softirq中的同步问题
softirq是由中断调用raise_softirq()而挂起的，我们可以简单粗暴的通过禁止本地中断来避免软中断
带来的并发访问。当然，我应该通过local_bh_disble()来禁止本地软中断。


## Q&A
Q1. 请解释process context和interrupt context的区别与区别的原因？
A1. 进程上下文是一种内核所处的操作模式，此时内核代表进程执行。中断上下文也是一种内核所处的操作模式，此时它不代表任何进程。然后interrupt context不可阻塞、休眠和抢占，process context可以。原因在于，中断程序不能像process那样被调度，一旦被休眠，则无法恢复执行。

原答案跑偏了（两者最大的区别为是否代表当前进程执行，更本质的，为是否引用当前进程的专有数据结构（`task_struct`）。什么是上下文？我们可以简单的理解为，一段程序运行所需要的所有外部变量。为什么有中断上下文？这由内核代码运行机制决定。内核主要有三种方式导致内核代码的运行，由中断引起中断处理程序的执行、由异常引起异常处理程序的执行和内核线程。中断由processor外部硬件设备发出，我们无法预测它的出现。异常是程序运行时发生的错误，它仍是当前进程的一部分。内核线程就是将一段内核代码变成一个可调度的特权线程。我们可以看出，中断是特别的，它天生和进程没什么太大关系，所以它有自己的上下文，即中断上下文。）

Q2. 请解释为什么中断分为top half和bottom half两个部分？
A2. 中断是频繁的（至少10ms一次的时钟中断），不可预测的（来自键盘的中断），粗暴的（直接中断当前代码的执行），不可阻塞的（要执行完，不可休眠）。内核必须保证中断处理成程序够快速执行以继续响应中断和恢复被中断程序的执行。故内核将中断处理分为top half和bottom half，top half（关闭对同类型中断的响应）负责答复中断，简洁迅速，bottom half（以开中断的方式）推后执行以完成更多的任务。

Q3. 请解释为什么在request_irq中需要dev？
`request_irq()`用于注册中断处理程序。dev是其中一个参数，类型为`void *dev`。中断线是可共享的。什么是中断线？可以简单理解为，它是用于联通硬件设备到中断控制器的物理线路，可被中断控制器根据物理位置获取中断号。可共享的中断线可注册多个中断程序，而这些中断程序就是借助dev来区分不同的设备的。
